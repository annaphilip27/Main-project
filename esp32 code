#include <WebSocketsServer.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include "camera_wrap.h"

#define DEBUG
// #define SAVE_IMG

const char* ssid = "unni"; //replace with your wifi ssid
const char* password = "unni@2002"; //replace with your wifi password

//holds the current upload
int cameraInitState = -1;
uint8_t* jpgBuff = nullptr; // Dynamically allocated buffer for image
size_t jpgLength = 0;

// Creating UDP Listener Object
WiFiUDP UDPServer;
unsigned int UDPPort = 6868;
IPAddress addrRemote;
int portRemote;

// Use WiFiClient class to create TCP connections
WiFiClient tcpClient;
bool clientConnected = false;

WebSocketsServer webSocket = WebSocketsServer(86);

const int RECVLENGTH = 8;
byte packetBuffer[RECVLENGTH];

unsigned long previousMillis = 0;
unsigned long previousMillisServo = 0;
const unsigned long interval = 30;
const unsigned long intervalServo = 100;

bool bStream = false;
int debugCnt = 0;

bool reqLeft = false;
bool reqRight = false;
bool reqFw = false;
bool reqBw = false;

const int PIN_SERVO_YAW = 12;
const int PIN_SERVO_PITCH = 2;
const int LED_BUILTIN = 4;
const int SERVO_RESOLUTION = 16;
int ledState = LOW;

int posYaw = 90;
int posPitch = 30;
int delta = 1;
const int angleMax = 180;
uint8_t camNo = 0;

void processData(){
  int cb = UDPServer.parsePacket();
  if (cb) {
    UDPServer.read(packetBuffer, RECVLENGTH);
    addrRemote = UDPServer.remoteIP();
    portRemote = UDPServer.remotePort();

    String strPackage = String((const char*)packetBuffer);
#ifdef DEBUG
    Serial.print("receive: ");
    Serial.print(strPackage);
    Serial.print(" from: ");
    Serial.println(addrRemote);
#endif
    if(strPackage.equals("whoami")){
      UDPServer.beginPacket(addrRemote, portRemote);
      String res = "ESP32-CAM";
      UDPServer.write((const uint8_t*)res.c_str(),res.length());
      UDPServer.endPacket();
      Serial.println("response");
    } else if(strPackage.equals("fwon")) {
      reqFw = true;
    } else if(strPackage.equals("bwon")) {
      reqBw = true;
    } else if(strPackage.equals("leon")) {
      reqLeft = true;
    } else if(strPackage.equals("rion")) {
      reqRight = true;
    } else if(strPackage.equals("fwoff")) {
      reqFw = false;
    } else if(strPackage.equals("bwoff")) {
      reqBw = false;
    } else if(strPackage.equals("leoff")) {
      reqLeft = false;
    } else if(strPackage.equals("rioff")) {
      reqRight = false;
    }
  }
  memset(packetBuffer, 0, RECVLENGTH);
}

void servoWrite(uint8_t pin, uint8_t angle) {
  // regarding the datasheet of sg90 servo, pwm period is 20 ms and duty is 1->2ms
  uint32_t maxDuty = (pow(2, SERVO_RESOLUTION) - 1) / 10; 
  uint32_t minDuty = (pow(2, SERVO_RESOLUTION) - 1) / 20; 
  uint32_t duty = (maxDuty - minDuty) * angle / 180 + minDuty;
  ledcWrite(pin, duty);
}

void controlServos(){
  if(reqFw && posPitch < 60){
    posPitch += 1;
  }
  if(reqBw && posPitch > 0){
    posPitch -= 1;
  }
  if(reqLeft && posYaw < 180){
    posYaw += 1;
  }
  if(reqRight && posYaw > 0){
    posYaw -= 1;
  }

  servoWrite(PIN_SERVO_PITCH, posPitch);
  servoWrite(PIN_SERVO_YAW, posYaw);
}

void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_DISCONNECTED:
      Serial.printf("[%u] Disconnected!\n", num);
      camNo = num;
      clientConnected = false;
      break;
    case WStype_CONNECTED:
      Serial.printf("[%u] Connected!\n", num);
      clientConnected = true;
      break;
    case WStype_TEXT:
    case WStype_BIN:
    case WStype_ERROR:
    case WStype_FRAGMENT_TEXT_START:
    case WStype_FRAGMENT_BIN_START:
    case WStype_FRAGMENT:
    case WStype_FRAGMENT_FIN:
      Serial.println(type);
      break;
  }
}

void setup(void) {
  Serial.begin(115200);
  Serial.print("\n");
#ifdef DEBUG
  Serial.setDebugOutput(true);
#endif

  cameraInitState = initCamera();

  Serial.printf("camera init state %d\n", cameraInitState);

  if(cameraInitState != 0){
    return;
  }

  // WIFI INIT
  Serial.printf("Connecting to %s\n", ssid);
  if (String(WiFi.SSID()) != String(ssid)) {
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
  }

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    ledState = (ledState == LOW) ? HIGH : LOW;
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected! IP address: ");
  Serial.println(WiFi.localIP());

  UDPServer.begin(UDPPort); 
  webSocket.begin();
  webSocket.onEvent(webSocketEvent);

  // Configure PWM for servos
  ledcAttach(PIN_SERVO_YAW, 50, SERVO_RESOLUTION);  // Attach servo to pin, 50 Hz frequency
  ledcAttach(PIN_SERVO_PITCH, 50, SERVO_RESOLUTION);  // Attach servo to pin, 50 Hz frequency
}

void loop(void) {
  webSocket.loop();
  
  if(clientConnected == true){
    // Dynamically allocate buffer before grabbing the image
    if (jpgBuff == nullptr) {
      jpgBuff = (uint8_t*)malloc(68123);
      if (jpgBuff == nullptr) {
        Serial.println("Memory allocation failed!");
        return;
      }
    }

    // Grab image and send over WebSocket
    grabImage(jpgLength, jpgBuff);
    Serial.printf("Sending image of size: %d bytes\n", jpgLength);
    webSocket.sendBIN(camNo, jpgBuff, jpgLength);

    // Free the buffer after sending the image
    free(jpgBuff);
    jpgBuff = nullptr;
  }

  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    processData();
  }
  if (currentMillis - previousMillisServo >= intervalServo) {
    previousMillisServo = currentMillis;
    controlServos();
  }
}
